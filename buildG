
import java.util.regex.*

war{
	
	def environment = System.properties['environment']
	def buildFile
	def lines
	def files = new LinkedHashMap<String, File>();
	
	
	if (environment.equals("local")){
		println "No environment provided, building with local files"
	}
	else
	{
		buildFile = new File("${buildFilesDir}build_${environment}.properties");
		lines = buildFile.readLines()
		def specialCharacters = "${specialCharacters}";
		specialCharacters = specialCharacters.split(',');
		
		println "Files to be updated:";	
		// Get the files names to be updated and their relative paths in project.
		lines.each { line -> 
		
			def file
			def key
			def value
			
			if( line.indexOf("File.") == 0 && !line.startsWith('#'))			
			{	
				key = line.split('=',2)[0];
				value = line.split('=',2)[1];
	
				try 
				{
					file = new File(value)
					if (file.exists() && !file.isDirectory()) 
					{	
						String filePrefix = key.substring( 5 , key.size());
						files.put(filePrefix,file);
						println file.getPath()
					} 
					else 
					{
						println "ERROR: ${value} does not exist."
						throw new FileNotFoundException();
					}
				} catch (Exception e) {
					println e
					throw e;
				}			
			}			
		}
			
		// Iterate files to be uploaded
		for (String fileKey : files.keySet()){
						
			File fileToBeUpdated = files.get(fileKey);			
			
			try
			{
				def fileContent = fileToBeUpdated.getText( 'UTF-8' ); 
				def fileURL = fileToBeUpdated.getPath().replace(fileToBeUpdated.getName(), "");
				def fileParts = fileToBeUpdated.getName().split('\\.(?=[^\\.]+$)'); 							 		 
				def fileName = fileParts[0];
				def fileExt = fileParts[1];
				
				println "\nBACKUP FILE ${fileURL}${fileName}.${fileExt}"; 
				
				copy 
				{       
					from "${fileURL}${fileName}.${fileExt}"
					into "${buildTempDir}"
					include("${fileName}.${fileExt}")
				}
				
				def key
				def value
			
				if (fileExt.equalsIgnoreCase("properties")) 
				{
					println "Updating properties file...";
					// Load properties file to be updated.
					def propsToBeUpdated = new Properties();          		
					def is;
					is = new FileInputStream( fileToBeUpdated );        		
					propsToBeUpdated.load( is );  
					is.close(); 	
					
					lines.each { line -> 
					
						if (line.indexOf('=') >= 0 && !line.startsWith('#')) 
						{
							key = line.split('=',2)[0];
							value = line.split('=',2)[1];
							
							if( key.startsWith(fileKey))
							{
								def propName = key.replace("${fileKey}.", "");
								def propValue = value;
								def newValue = "${propName}=${propValue}";
								
								// if value exist in original then it replaces it
								def propToBeUpdated = propsToBeUpdated.get(propName);
								if(propToBeUpdated != null)
								{
									def oldValue = "${propName}=${propToBeUpdated}"
									fileContent = fileContent.replace(oldValue, newValue);
								} 
								else
								{
									fileContent+= "\r\n${propName}=${value}";
								}
								println "${propName}=${value}"
							} 
						}	  	
					}
				
				} 
				else 
				{
					println "Updating NON properties file...";
					
					lines.each { line -> 
					
						if (line.indexOf('=') >= 0 && !line.startsWith('#')) 
						{
							key = line.split('=',2)[0];
							value = line.split('=',2)[1];
							
							if( key.equals(fileKey) )
							{
								Pattern p = Pattern.compile("replace\\((.+?)\\)\\.with\\((.*?)\\)");
								Matcher m = p.matcher(value);  
								
								if(m.matches())
								{	  
									def tokenToBeReplaced = value.substring( 8, value.indexOf( ").with" ));
									def newToken = value.substring(value.indexOf("with(") + 5, value.size()-1);
									tokenToBeReplaced = tokenToBeReplaced.replace("\\", "\\\\");											
									newToken = newToken.replace("\\", "\\\\");	
									
										for(String sChar : specialCharacters){											
											tokenToBeReplaced = tokenToBeReplaced.replace(sChar, "\\"+sChar);											
											newToken = newToken.replace(sChar, "\\"+sChar);
									
										}								
									
									println "Replacing ${tokenToBeReplaced} WITH ${newToken}";
									fileContent = fileContent.replaceAll( tokenToBeReplaced, newToken );
								}
								else{
									println "INVALID TOKEN ENTRY: " + value;
								}
							}   
						}	 	
					}
				}
				
				new File("${fileURL}${fileName}.${fileExt}").write( fileContent, 'UTF-8' );
				
			}			
			catch (Exception ex) {
				
				println "ERROR: BUILD STOPED, RESTORING LOCAL FILES";
				for (String bFileKey : files.keySet()){
					File updatedFile = files.get(bFileKey);
				
					def fileURL = updatedFile.getPath().replace(updatedFile.getName(), "");
					def fileParts = updatedFile.getName().split('\\.(?=[^\\.]+$)'); 							 		 
					def fileName = fileParts[0];
					def fileExt = fileParts[1];
					
					println "GETTING BACKUP FILE ${buildTempDir}${fileName}.${fileExt}";
					copy 
					{        
						from "${buildTempDir}${fileName}.${fileExt}"
						into fileURL
						include("${fileName}.${fileExt}")
					}
				}
				
				delete "${buildTempDir}"
				throw ex;			
			}
		}
		println "Files were successfully updated.";
	}

	rootSpec.exclude('**/buildFiles')
	
	manifest {
        attributes("UseWSFEP61ScanPolicy": true);
        attributes("Class-Path": "")
    }
	
	doLast 
	{	
		for (String fileKey : files.keySet()){
			File updatedFile = files.get(fileKey);
		
			def fileURL = updatedFile.getPath().replace(updatedFile.getName(), "");
    		def fileParts = updatedFile.getName().split('\\.(?=[^\\.]+$)'); 							 		 
			def fileName = fileParts[0];
			def fileExt = fileParts[1];
    		
    		println "GETTING BACKUP FILE ${buildTempDir}${fileName}.${fileExt}";
			copy 
		    {        
			    from "${buildTempDir}${fileName}.${fileExt}"
			    into fileURL
			    include("${fileName}.${fileExt}")
		 	}
		}
		
		delete "${buildTempDir}"
	}
}

war.outputs.upToDateWhen { false }
